name: deploy-staging

on:
  push:
    branches: [ develop, 'release/**' ]
    paths:
      - 'ops/**'
      - '.github/workflows/deploy-staging.yml'
      - 'frontend/**'
      - 'users-api/**'
      - 'auth-api/**'
      - 'todos-api/**'
      - 'log-message-processor/**'
  workflow_dispatch:

concurrency:
  group: staging-deploy
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: staging  # usa los Environment secrets de “staging”

    steps:
      - uses: actions/checkout@v4

      # 1) Prueba de conectividad SSH
      - name: Test SSH connectivity
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            echo "✅ SSH OK en $(hostname)"
            uname -a

      # 2) Asegura carpeta destino en la VM
      - name: Ensure remote dir
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e
            APP_DIR=/opt/microservice-app-stg
            sudo mkdir -p "$APP_DIR"
            sudo chown "$USER:$USER" "$APP_DIR"
            echo "APP_DIR=$APP_DIR"

      # 3) Copia archivos de compose/nginx
      - name: Copy compose files to remote
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: "ops/compose/.env,ops/compose/docker-compose.stg.yml,ops/compose/nginx.conf"
          target: "/opt/microservice-app-stg"
          strip_components: 2
          overwrite: true

      # 4) Pull & Up (staging)
      - name: Pull & Up (staging)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e
            APP_DIR=/opt/microservice-app-stg
            cd "$APP_DIR"

            # Renombra el compose de staging a docker-compose.yml
            mv -f docker-compose.stg.yml docker-compose.yml

            docker --version
            docker compose version

            sudo docker compose pull
            sudo docker compose up -d --remove-orphans

            sudo docker compose ps

      # 5) Detecta el puerto real de auth-api y parchea nginx.conf (__AUTH_PORT__ -> puerto)
      - name: Patch Nginx with real auth-api port & reload
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e
            APP_DIR=/opt/microservice-app-stg
            cd "$APP_DIR"

            # Busca el puerto real en logs (línea "http server started on [::]:PORT")
            APORT=$(sudo docker compose logs --tail=200 auth-api \
              | awk -F'[][]' '/http server started/{print $NF}' \
              | grep -oE '[0-9]{4,5}$' | tail -1)

            if [ -z "$APORT" ]; then
              echo "❌ No pude detectar el puerto de auth-api. Logs recientes:"
              sudo docker compose logs --tail=200 auth-api
              exit 1
            fi
            echo "🔎 auth-api real port: $APORT"

            # Sustituye marcador en nginx.conf y recrea solo Nginx
            sudo sed -i -E "s#__AUTH_PORT__#${APORT}#g" nginx.conf
            sudo docker compose up -d --force-recreate nginx

      # 6) Smoke tests con JWT (users-api devuelve 500 sin Authorization)
      - name: Smoke tests (JWT)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e
            APP_DIR=/opt/microservice-app-stg
            cd "$APP_DIR"

            # 200 en /
            CODE_ROOT=$(curl -sS -o /dev/null -w "%{http_code}" http://localhost/)
            echo "/ -> $CODE_ROOT"
            [ "$CODE_ROOT" = "200" ] || (echo "Root no responde 200"; exit 1)

            # Genera JWT HS256 con el mismo secreto del .env
            JWT_SECRET=$(grep -E '^JWT_SECRET=' .env | cut -d= -f2-)
            if [ -z "$JWT_SECRET" ]; then echo "Falta JWT_SECRET en .env"; exit 1; fi

            TOKEN=$(SECRET="$JWT_SECRET" python3 - <<'PY'
            import os,json,base64,hmac,hashlib,time
            def b64url(b): return base64.urlsafe_b64encode(b).rstrip(b'=')
            h={"alg":"HS256","typ":"JWT"}
            now=int(time.time())
            p={"sub":"demo","name":"Demo User","iat":now,"nbf":now-5,"exp":now+3600,"roles":["USER"]}
            sec=os.environ.get("SECRET","change_this_secret").encode()
            seg=[b64url(json.dumps(h,separators=(',',':')).encode()), b64url(json.dumps(p,separators=(',',':')).encode())]
            sig=b64url(hmac.new(sec,b'.'.join(seg),hashlib.sha256).digest())
            print((b'.'.join(seg)+b'.'+sig).decode())
            PY
            )
            echo "JWT prefix: ${TOKEN:0:20}..."

            # /api/users/ y /api/todos/ con Authorization deben dar 200
            CODE_USERS=$(curl -sS -H "Authorization: Bearer $TOKEN" -o /dev/null -w "%{http_code}" http://localhost/api/users/)
            CODE_TODOS=$(curl -sS -H "Authorization: Bearer $TOKEN" -o /dev/null -w "%{http_code}" http://localhost/api/todos/)
            echo "/api/users/ -> $CODE_USERS"
            echo "/api/todos/ -> $CODE_TODOS"

            [ "$CODE_USERS" = "200" ] || (echo "users-api no OK ($CODE_USERS)"; exit 1)
            [ "$CODE_TODOS" = "200" ] || (echo "todos-api no OK ($CODE_TODOS)"; exit 1)

            echo " Smoke OK con JWT"
