name: deploy-staging

on:
  push:
    branches: [ develop, 'release/**' ]
    paths:
      - 'ops/**'
      - '.github/workflows/deploy-staging.yml'
      - 'frontend/**'
      - 'users-api/**'
      - 'auth-api/**'
      - 'todos-api/**'
      - 'log-message-processor/**'
  workflow_dispatch:

concurrency:
  group: staging-deploy
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: staging  # usa los Environment secrets de “staging”

    steps:
      - uses: actions/checkout@v4

      # 1) Prueba de conectividad SSH
      - name: Test SSH connectivity
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            echo "✅ SSH OK en $(hostname)"
            uname -a

      # 2) Asegura carpeta destino en la VM
      - name: Ensure remote dir
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e
            APP_DIR=/opt/microservice-app-stg
            sudo mkdir -p "$APP_DIR"
            sudo chown "$USER:$USER" "$APP_DIR"
            echo "APP_DIR=$APP_DIR"

      # 3) Copia archivos de compose/nginx
      - name: Copy compose files to remote
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: "ops/compose/.env,ops/compose/docker-compose.stg.yml,ops/compose/nginx.conf"
          target: "/opt/microservice-app-stg"
          strip_components: 2
          overwrite: true

      # 4) Pull & Up (staging)
      - name: Pull & Up (staging)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e
            APP_DIR=/opt/microservice-app-stg
            cd "$APP_DIR"

            # Renombra el compose de staging a docker-compose.yml
            mv -f docker-compose.stg.yml docker-compose.yml

            # Verificaciones mínimas
            docker --version
            docker compose version

            # Pull y Up
            sudo docker compose pull
            sudo docker compose up -d --remove-orphans

            sudo docker compose ps

      # 5) Detecta el puerto real de auth-api y parchea nginx.conf (__AUTH_PORT__ -> puerto)
      - name: Patch Nginx with real auth-api port & reload
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e
            APP_DIR=/opt/microservice-app-stg
            cd "$APP_DIR"

            # Busca el puerto real en logs (línea "http server started on [::]:PORT")
            APORT=$(sudo docker compose logs --tail=200 auth-api \
              | awk -F'[][]' '/http server started/{print $NF}' \
              | grep -oE '[0-9]{4,5}$' | tail -1)

            if [ -z "$APORT" ]; then
              echo "❌ No pude detectar el puerto de auth-api. Logs recientes:"
              sudo docker compose logs --tail=200 auth-api
              exit 1
            fi
            echo "🔎 auth-api real port: $APORT"

            # Sustituye marcador en nginx.conf y recrea solo Nginx
            sudo sed -i -E "s#__AUTH_PORT__#${APORT}#g" nginx.conf
            sudo docker compose up -d --force-recreate nginx

      # 6) Smoke tests básicos
      - name: Smoke tests
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e
            APP_DIR=/opt/microservice-app-stg
            cd "$APP_DIR"

            # 200 en /
            CODE_ROOT=$(curl -sS -o /dev/null -w "%{http_code}" http://localhost/)
            echo "/ -> $CODE_ROOT"
            [ "$CODE_ROOT" = "200" ] || (echo "Root no responde 200"; exit 1)

            # /api/users/ y /api/todos/ deberían responder 401 sin token (o 200 si están abiertos)
            CODE_USERS=$(curl -sS -o /dev/null -w "%{http_code}" http://localhost/api/users/)
            CODE_TODOS=$(curl -sS -o /dev/null -w "%{http_code}" http://localhost/api/todos/)
            echo "/api/users/ -> $CODE_USERS"
            echo "/api/todos/ -> $CODE_TODOS"

            case "$CODE_USERS" in 200|401) : ;; *) echo "users-api no OK ($CODE_USERS)"; exit 1;; esac
            case "$CODE_TODOS" in 200|401) : ;; *) echo "todos-api no OK ($CODE_TODOS)"; exit 1;; esac

            echo "✅ Smoke OK"
